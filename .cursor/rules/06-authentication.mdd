# Authentication & Authorization

## Authentication Strategy
- **Method**: JWT (JSON Web Tokens)
- **Library**: fast-jwt
- **Token Types**: Access Token + Refresh Token
- **Password Hashing**: bcrypt with 10 salt rounds

## JWT Token Strategy

### Token Lifetimes
- **Access Token**: 15 minutes
  - Short-lived for security
  - Used for API authentication
  - Stored in localStorage (client)
  
- **Refresh Token**: 7 days
  - Long-lived for better UX
  - Used to obtain new access tokens
  - Stored in localStorage + database

### Token Payload
```typescript
// src/types/jwt.types.ts
export interface TokenPayload {
  userId: number
  role: string
}
```

## User Roles & Permissions

### Role Enum (src/constants/type.ts)
```typescript
export enum Role {
  Owner = 'Owner',      // Admin - Full access
  Employee = 'Employee', // Staff - Limited access
  Guest = 'Guest'        // Customer - Public only
}
```

### Permission Matrix
| Feature | Owner | Employee | Guest |
|---------|-------|----------|-------|
| Manage Employees | ✅ | ❌ | ❌ |
| Manage Menu | ✅ | ❌ | ❌ |
| Manage Tables | ✅ | ❌ | ❌ |
| View Orders | ✅ | ✅ | Own only |
| Process Orders | ✅ | ✅ | ❌ |
| View Statistics | ✅ | ✅ | ❌ |
| Place Orders | ❌ | ❌ | ✅ |

## JWT Utilities (Server)

### Location: `src/utils/jwt.ts`

```typescript
import { createSigner, createVerifier } from 'fast-jwt'
import envConfig from '@/config'
import type { TokenPayload } from '@/types/jwt.types'

// Create token signer
const accessTokenSigner = createSigner({
  key: envConfig.JWT_SECRET,
  expiresIn: 15 * 60 * 1000 // 15 minutes in ms
})

const refreshTokenSigner = createSigner({
  key: envConfig.JWT_REFRESH_SECRET,
  expiresIn: 7 * 24 * 60 * 60 * 1000 // 7 days in ms
})

// Create token verifier
const accessTokenVerifier = createVerifier({
  key: envConfig.JWT_SECRET
})

const refreshTokenVerifier = createVerifier({
  key: envConfig.JWT_REFRESH_SECRET
})

/**
 * Sign a JWT token
 * @param payload - Token payload
 * @param type - Token type (access or refresh)
 * @returns Signed JWT token
 */
export const signToken = (payload: TokenPayload, type: 'access' | 'refresh' = 'access') => {
  const signer = type === 'access' ? accessTokenSigner : refreshTokenSigner
  return signer(payload)
}

/**
 * Verify a JWT token
 * @param token - JWT token to verify
 * @param type - Token type (access or refresh)
 * @returns Decoded payload
 */
export const verifyToken = (token: string, type: 'access' | 'refresh' = 'access'): TokenPayload => {
  const verifier = type === 'access' ? accessTokenVerifier : refreshTokenVerifier
  return verifier(token)
}
```

## Password Hashing (Server)

### Location: `src/utils/crypto.ts`

```typescript
import bcrypt from 'bcrypt'

const SALT_ROUNDS = 10

/**
 * Hash password with bcrypt
 * @param password - Plain text password
 * @returns Hashed password
 */
export const hashPassword = (password: string): string => {
  return bcrypt.hashSync(password, SALT_ROUNDS)
}

/**
 * Compare password with hash
 * @param password - Plain text password
 * @param hash - Hashed password
 * @returns True if match
 */
export const comparePassword = (password: string, hash: string): boolean => {
  return bcrypt.compareSync(password, hash)
}
```

## Authentication Flow

### 1. Registration (Owner/Employee)

#### Server Controller
```typescript
export const registerController = async (body: RegisterBodyType) => {
  // 1. Check if email exists
  const existing = await prisma.account.findUnique({
    where: { email: body.email }
  })
  
  if (existing) {
    throw new EntityError({
      status: 422,
      errors: [{ field: 'email', message: 'Email đã tồn tại' }]
    })
  }
  
  // 2. Hash password
  const hashedPassword = hashPassword(body.password)
  
  // 3. Create user
  const user = await prisma.account.create({
    data: {
      name: body.name,
      email: body.email,
      password: hashedPassword,
      role: body.role || 'Employee'
    }
  })
  
  // 4. Don't return password
  const { password, ...userWithoutPassword } = user
  
  return {
    data: userWithoutPassword,
    message: 'Đăng ký thành công'
  }
}
```

### 2. Login

#### Server Controller
```typescript
export const loginController = async (body: LoginBodyType) => {
  // 1. Find user
  const user = await prisma.account.findUnique({
    where: { email: body.email }
  })
  
  if (!user) {
    throw new EntityError({
      status: 422,
      errors: [{ field: 'email', message: 'Email hoặc mật khẩu không đúng' }]
    })
  }
  
  // 2. Verify password
  const isValid = comparePassword(body.password, user.password)
  
  if (!isValid) {
    throw new EntityError({
      status: 422,
      errors: [{ field: 'password', message: 'Email hoặc mật khẩu không đúng' }]
    })
  }
  
  // 3. Generate tokens
  const payload: TokenPayload = { userId: user.id, role: user.role }
  const accessToken = signToken(payload, 'access')
  const refreshToken = signToken(payload, 'refresh')
  
  // 4. Store refresh token in database
  await prisma.refreshToken.create({
    data: {
      token: refreshToken,
      accountId: user.id,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    }
  })
  
  // 5. Return response
  const { password, ...userWithoutPassword } = user
  
  return {
    data: {
      accessToken,
      refreshToken,
      account: userWithoutPassword
    },
    message: 'Đăng nhập thành công'
  }
}
```

#### Client API Request
```typescript
// apiRequests/auth.ts
const authApiRequest = {
  sLogin: (body: LoginBodyType) => 
    http.post<LoginResType>('/api/auth/login', body, { baseUrl: '' })
}
```

#### Client Mutation Hook
```typescript
// queries/useAuth.tsx
'use client'
export const useLoginMutation = () => {
  const router = useRouter()
  
  return useMutation({
    mutationFn: authApiRequest.sLogin,
    onSuccess: (data) => {
      // Tokens are auto-stored by http client
      toast.success('Đăng nhập thành công')
      router.push('/manage/dashboard')
    },
    onError: (error) => {
      toast.error(error.message)
    }
  })
}
```

### 3. Token Storage & Management (Client)

#### HTTP Client Auto-Handler (lib/http.ts)
```typescript
class HttpClient {
  async post<T>(url: string, body?: any, options?: CustomOptions): Promise<T> {
    // ... fetch logic ...
    
    // Auto-store tokens after login
    if (url.includes('/login')) {
      const data = await response.json()
      setAccessTokenToLocalStorage(data.data.accessToken)
      setRefreshTokenToLocalStorage(data.data.refreshToken)
    }
    
    // Auto-attach Authorization header
    const headers = {
      ...defaultHeaders,
      Authorization: `Bearer ${getAccessTokenFromLocalStorage()}`
    }
    
    return response.json()
  }
}
```

#### Token Utilities (lib/utils.ts)
```typescript
export const setAccessTokenToLocalStorage = (token: string) => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('accessToken', token)
  }
}

export const setRefreshTokenToLocalStorage = (token: string) => {
  if (typeof window !== 'undefined') {
    localStorage.setItem('refreshToken', token)
  }
}

export const getAccessTokenFromLocalStorage = () => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('accessToken')
  }
  return null
}

export const getRefreshTokenFromLocalStorage = () => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('refreshToken')
  }
  return null
}

export const removeTokensFromLocalStorage = () => {
  if (typeof window !== 'undefined') {
    localStorage.removeItem('accessToken')
    localStorage.removeItem('refreshToken')
  }
}
```

### 4. Token Refresh

#### Server Controller
```typescript
export const refreshTokenController = async (body: RefreshTokenBodyType) => {
  // 1. Verify refresh token
  const payload = verifyToken(body.refreshToken, 'refresh')
  
  // 2. Check if token exists in database
  const storedToken = await prisma.refreshToken.findFirst({
    where: {
      token: body.refreshToken,
      accountId: payload.userId,
      expiresAt: { gt: new Date() }
    }
  })
  
  if (!storedToken) {
    throw new Error('Refresh token không hợp lệ')
  }
  
  // 3. Generate new tokens
  const newAccessToken = signToken({ userId: payload.userId, role: payload.role }, 'access')
  const newRefreshToken = signToken({ userId: payload.userId, role: payload.role }, 'refresh')
  
  // 4. Delete old refresh token
  await prisma.refreshToken.delete({
    where: { id: storedToken.id }
  })
  
  // 5. Store new refresh token
  await prisma.refreshToken.create({
    data: {
      token: newRefreshToken,
      accountId: payload.userId,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    }
  })
  
  return {
    data: {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken
    },
    message: 'Refresh token thành công'
  }
}
```

#### Client Auto-Refresh Component
```typescript
// components/refresh-token.tsx
'use client'
export default function RefreshToken() {
  useEffect(() => {
    const interval = setInterval(async () => {
      const refreshToken = getRefreshTokenFromLocalStorage()
      if (refreshToken) {
        try {
          const res = await authApiRequest.sRefreshToken({ refreshToken })
          setAccessTokenToLocalStorage(res.data.accessToken)
          setRefreshTokenToLocalStorage(res.data.refreshToken)
        } catch (error) {
          removeTokensFromLocalStorage()
          router.push('/login')
        }
      }
    }, 14 * 60 * 1000) // Refresh every 14 minutes
    
    return () => clearInterval(interval)
  }, [])
  
  return null
}
```

### 5. Logout

#### Server Controller
```typescript
export const logoutController = async (refreshToken: string) => {
  // Delete refresh token from database
  await prisma.refreshToken.deleteMany({
    where: { token: refreshToken }
  })
  
  return 'Đăng xuất thành công'
}
```

#### Client Logout
```typescript
export const useLogoutMutation = () => {
  const router = useRouter()
  
  return useMutation({
    mutationFn: async () => {
      const refreshToken = getRefreshTokenFromLocalStorage()
      await authApiRequest.sLogout({ refreshToken })
    },
    onSuccess: () => {
      removeTokensFromLocalStorage()
      router.push('/login')
    }
  })
}
```

## Protected Routes

### Server-Side Protection (Auth Hook)
```typescript
// hooks/auth.hooks.ts
export const requireLoginedHook = async (request: FastifyRequest, reply: FastifyReply) => {
  const token = request.headers.authorization?.replace('Bearer ', '')
  
  if (!token) {
    return reply.status(401).send({ statusCode: 401, message: 'Unauthorized' })
  }
  
  try {
    const decoded = verifyToken(token, 'access')
    request.user = { userId: decoded.userId, role: decoded.role }
  } catch (error) {
    return reply.status(401).send({ statusCode: 401, message: 'Invalid token' })
  }
}

// Role-based hook
export const requireOwnerHook = async (request: FastifyRequest, reply: FastifyReply) => {
  if (request.user.role !== 'Owner') {
    return reply.status(403).send({ statusCode: 403, message: 'Forbidden' })
  }
}
```

### Client-Side Protection (Middleware)
```typescript
// middleware.ts
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Protected routes
  if (pathname.startsWith('/manage')) {
    const token = request.cookies.get('accessToken')?.value
    
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url))
    }
  }
  
  return NextResponse.next()
}
```

## Security Best Practices

1. ✅ **Never log tokens** or passwords
2. ✅ **Always hash passwords** with bcrypt (never store plain text)
3. ✅ **Use HTTPS** in production
4. ✅ **Validate tokens** on every request
5. ✅ **Expire tokens** appropriately
6. ✅ **Store refresh tokens** in database for revocation
7. ✅ **Rate limit** login attempts
8. ✅ **Sanitize error messages** (don't reveal user existence)
9. ✅ **Use secure cookie flags** (httpOnly, secure, sameSite)
10. ✅ **Implement logout** properly (clear all tokens)

