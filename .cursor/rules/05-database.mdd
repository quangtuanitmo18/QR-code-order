# Database & Prisma

## Database Overview
- **Type**: SQLite (file-based relational database)
- **Location**: `server/prisma/dev.db`
- **ORM**: Prisma 5.16+
- **Migration**: Prisma Migrate

## Prisma Client Setup

### Database Client (src/database/index.ts)
```typescript
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error']
  })
}

declare global {
  var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

if (process.env.NODE_ENV !== 'production') {
  globalThis.prisma = prisma
}

export default prisma
```

### Usage
```typescript
// Always import from @/database
import prisma from '@/database'

const users = await prisma.account.findMany()
```

## Database Schema Key Models

### Account (Users)
```prisma
model Account {
  id           Int            @id @default(autoincrement())
  name         String
  email        String         @unique
  password     String
  avatar       String?
  role         Role           @default(Employee)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  refreshTokens RefreshToken[]
  orders       Order[]
}

enum Role {
  Owner
  Employee
}
```

### Dish (Menu Items)
```prisma
model Dish {
  id          Int           @id @default(autoincrement())
  name        String
  price       Int
  description String
  image       String
  status      DishStatus    @default(Available)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  orderDetails OrderDetail[]
}

enum DishStatus {
  Available
  Unavailable
  Hidden
}
```

### Table
```prisma
model Table {
  id        Int          @id @default(autoincrement())
  number    Int          @unique
  capacity  Int
  status    TableStatus  @default(Available)
  token     String?      @unique
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  orders    Order[]
}

enum TableStatus {
  Available
  Reserved
  Hidden
}
```

### Order
```prisma
model Order {
  id           Int           @id @default(autoincrement())
  guestId      Int?
  guest        Guest?        @relation(fields: [guestId], references: [id], onDelete: SetNull)
  tableNumber  Int?
  table        Table?        @relation(fields: [tableNumber], references: [number], onDelete: SetNull)
  dishSnapshotArray Json?
  status       OrderStatus   @default(Pending)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  orderDetails OrderDetail[]
  paidBy       Account?      @relation(fields: [paidById], references: [id])
  paidById     Int?
}

enum OrderStatus {
  Pending
  Processing
  Rejected
  Delivered
  Paid
}
```

## CRUD Operations

### Create
```typescript
// Single record
const user = await prisma.account.create({
  data: {
    name: 'John Doe',
    email: 'john@example.com',
    password: hashedPassword,
    role: 'Employee'
  }
})

// Multiple records
await prisma.dish.createMany({
  data: [
    { name: 'Dish 1', price: 100000, description: 'Desc 1', image: 'img1.jpg' },
    { name: 'Dish 2', price: 150000, description: 'Desc 2', image: 'img2.jpg' }
  ]
})
```

### Read
```typescript
// Find unique (by unique field)
const user = await prisma.account.findUnique({
  where: { email: 'john@example.com' },
  select: {
    id: true,
    name: true,
    email: true,
    role: true
    // Exclude password
  }
})

// Find first match
const dish = await prisma.dish.findFirst({
  where: { status: 'Available' }
})

// Find many with filters
const dishes = await prisma.dish.findMany({
  where: {
    status: 'Available',
    price: { lte: 200000 }
  },
  orderBy: { createdAt: 'desc' },
  take: 10,
  skip: 0
})

// Find many with relations
const orders = await prisma.order.findMany({
  include: {
    guest: true,
    table: true,
    orderDetails: {
      include: {
        dish: true
      }
    }
  }
})

// Count records
const totalOrders = await prisma.order.count({
  where: { status: 'Pending' }
})
```

### Update
```typescript
// Update single record
const updatedUser = await prisma.account.update({
  where: { id: userId },
  data: {
    name: 'New Name',
    updatedAt: new Date()
  }
})

// Update many records
await prisma.dish.updateMany({
  where: { status: 'Unavailable' },
  data: { status: 'Available' }
})

// Upsert (update or create)
const dish = await prisma.dish.upsert({
  where: { id: dishId },
  update: { price: 120000 },
  create: {
    name: 'New Dish',
    price: 120000,
    description: 'Description',
    image: 'image.jpg'
  }
})
```

### Delete
```typescript
// Delete single record
await prisma.account.delete({
  where: { id: userId }
})

// Delete many records
await prisma.refreshToken.deleteMany({
  where: {
    expiresAt: { lt: new Date() }
  }
})
```

## Transactions

### Use for Multi-Step Operations
```typescript
// Create order with order details
const order = await prisma.$transaction(async (tx) => {
  // 1. Create order
  const newOrder = await tx.order.create({
    data: {
      guestId: guestId,
      tableNumber: tableNumber,
      status: 'Pending'
    }
  })
  
  // 2. Create order details
  await tx.orderDetail.createMany({
    data: dishes.map(dish => ({
      orderId: newOrder.id,
      dishId: dish.id,
      quantity: dish.quantity,
      price: dish.price
    }))
  })
  
  // 3. Update table status
  await tx.table.update({
    where: { number: tableNumber },
    data: { status: 'Reserved' }
  })
  
  return newOrder
})

// Transaction with rollback on error
try {
  await prisma.$transaction(async (tx) => {
    // Multiple operations
    // If any fails, all will rollback
  })
} catch (error) {
  console.error('Transaction failed:', error)
}
```

## Advanced Queries

### Aggregations
```typescript
// Sum
const totalRevenue = await prisma.order.aggregate({
  where: { status: 'Paid' },
  _sum: { total: true }
})

// Average
const avgOrderValue = await prisma.order.aggregate({
  _avg: { total: true }
})

// Count, min, max
const stats = await prisma.order.aggregate({
  _count: true,
  _min: { createdAt: true },
  _max: { createdAt: true }
})
```

### Group By
```typescript
// Revenue by date
const revenueByDate = await prisma.order.groupBy({
  by: ['createdAt'],
  where: { status: 'Paid' },
  _sum: { total: true },
  orderBy: { createdAt: 'desc' }
})

// Orders by status
const ordersByStatus = await prisma.order.groupBy({
  by: ['status'],
  _count: true
})
```

### Raw Queries (when needed)
```typescript
// Raw SQL query
const result = await prisma.$queryRaw`
  SELECT DATE(createdAt) as date, SUM(total) as revenue
  FROM Order
  WHERE status = 'Paid'
  GROUP BY DATE(createdAt)
  ORDER BY date DESC
`

// Execute raw SQL
await prisma.$executeRaw`
  UPDATE Dish SET status = 'Hidden' WHERE updatedAt < ${cutoffDate}
`
```

## Relations & Joins

### Include Relations
```typescript
// One-to-many
const user = await prisma.account.findUnique({
  where: { id: userId },
  include: {
    orders: true,
    refreshTokens: true
  }
})

// Nested relations
const order = await prisma.order.findUnique({
  where: { id: orderId },
  include: {
    guest: true,
    table: true,
    orderDetails: {
      include: {
        dish: true
      }
    },
    paidBy: {
      select: {
        id: true,
        name: true
      }
    }
  }
})
```

### Select Specific Fields
```typescript
// Select instead of include (more efficient)
const orders = await prisma.order.findMany({
  select: {
    id: true,
    status: true,
    createdAt: true,
    guest: {
      select: {
        name: true,
        tableNumber: true
      }
    },
    orderDetails: {
      select: {
        quantity: true,
        price: true,
        dish: {
          select: {
            name: true,
            image: true
          }
        }
      }
    }
  }
})
```

## Filtering

### Comparison Operators
```typescript
await prisma.dish.findMany({
  where: {
    price: {
      gte: 50000,  // >= greater than or equal
      lte: 200000  // <= less than or equal
    }
  }
})

await prisma.order.findMany({
  where: {
    createdAt: {
      gt: new Date('2024-01-01'),  // > greater than
      lt: new Date('2024-12-31')   // < less than
    }
  }
})
```

### Logical Operators
```typescript
// AND (default)
await prisma.dish.findMany({
  where: {
    status: 'Available',
    price: { lte: 100000 }
  }
})

// OR
await prisma.dish.findMany({
  where: {
    OR: [
      { status: 'Available' },
      { status: 'Hidden' }
    ]
  }
})

// NOT
await prisma.account.findMany({
  where: {
    NOT: {
      role: 'Owner'
    }
  }
})
```

### String Filters
```typescript
await prisma.dish.findMany({
  where: {
    name: {
      contains: 'pizza',     // Case sensitive
      startsWith: 'Pizza',
      endsWith: 'Special'
    }
  }
})
```

## Pagination

### Offset Pagination
```typescript
const page = 2
const limit = 10
const skip = (page - 1) * limit

const [dishes, total] = await Promise.all([
  prisma.dish.findMany({
    skip,
    take: limit,
    orderBy: { createdAt: 'desc' }
  }),
  prisma.dish.count()
])

const result = {
  data: dishes,
  pagination: {
    page,
    limit,
    total,
    totalPages: Math.ceil(total / limit)
  }
}
```

### Cursor Pagination (more efficient for large datasets)
```typescript
const dishes = await prisma.dish.findMany({
  take: 10,
  cursor: lastId ? { id: lastId } : undefined,
  skip: lastId ? 1 : 0,
  orderBy: { id: 'asc' }
})
```

## Indexes & Performance

### Add Indexes in Schema
```prisma
model Order {
  id          Int         @id @default(autoincrement())
  status      OrderStatus
  createdAt   DateTime    @default(now())
  
  // Composite index for frequently queried fields
  @@index([status, createdAt])
}

model Account {
  id    Int    @id @default(autoincrement())
  email String @unique  // Automatically indexed
  
  @@index([role])  // Index on role for filtering
}
```

### Query Optimization Tips
1. ✅ **Use `select`** instead of including all fields
2. ✅ **Add indexes** on frequently filtered/sorted fields
3. ✅ **Avoid N+1 queries** - use `include` or `select` with relations
4. ✅ **Use transactions** for data integrity
5. ✅ **Batch operations** with `createMany`, `updateMany`, `deleteMany`
6. ✅ **Use aggregations** instead of fetching all records

## Migrations

### Development
```bash
# Create migration
npx prisma migrate dev --name add_user_table

# Reset database (⚠️ deletes data)
npx prisma migrate reset

# Generate Prisma Client after schema changes
npx prisma generate
```

### Production
```bash
# Apply migrations
npx prisma migrate deploy

# View migration status
npx prisma migrate status
```

## Best Practices

1. ✅ **Always use transactions** for multi-step operations
2. ✅ **Select only needed fields** to reduce payload size
3. ✅ **Add database indexes** on frequently queried columns
4. ✅ **Use enums** for status fields (type-safe)
5. ✅ **Handle unique constraint errors** gracefully
6. ✅ **Never expose password fields** in queries
7. ✅ **Use soft deletes** for important data (add `deletedAt` field)
8. ✅ **Validate data** before database operations
9. ✅ **Use connection pooling** (Prisma handles this automatically)
10. ✅ **Log slow queries** in development

## Common Patterns

### Soft Delete
```typescript
// Add to schema
model Account {
  id        Int       @id @default(autoincrement())
  deletedAt DateTime?
}

// Soft delete
await prisma.account.update({
  where: { id: userId },
  data: { deletedAt: new Date() }
})

// Query non-deleted records
await prisma.account.findMany({
  where: { deletedAt: null }
})
```

### Timestamps
```typescript
// Auto-managed by Prisma
model Account {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt  // Auto-updated on changes
}
```

### JSON Fields
```typescript
// Store JSON data
model Order {
  id                Int   @id @default(autoincrement())
  dishSnapshotArray Json? // Store dish snapshots
}

// Usage
await prisma.order.create({
  data: {
    dishSnapshotArray: JSON.stringify([
      { name: 'Dish 1', price: 100000 },
      { name: 'Dish 2', price: 150000 }
    ])
  }
})
```

